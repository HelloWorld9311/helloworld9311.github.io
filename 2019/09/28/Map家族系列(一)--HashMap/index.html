<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Map家族系列(一)——HashMap | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Java、HashMap/">Java、HashMap</a></div><div class="post-time">2019-09-28</div></div></div><div class="container post-header"><h1>Map家族系列(一)——HashMap</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap经历了什么"><span class="toc-number">1.</span> <span class="toc-text">HashMap经历了什么</span></a></li></ol></details></div><div class="container post-content"><h1 id="HashMap经历了什么"><a href="#HashMap经历了什么" class="headerlink" title="HashMap经历了什么"></a>HashMap经历了什么</h1><ol>
<li><p><strong>写在最前面</strong></p>
<p>​        日常开发中，HashMap的使用频率不可谓不频繁，<strong>key/value</strong>结构使用起来非常方便，JDK在提供出来的版本中也对HashMap进行了不断的优化，存储和查找的性能不断得到提升，本文基于JDK1.8对Hash Map的使用过程进行分析，对源码进行解读。</p>
</li>
<li><p><strong>创建一个HashMap对象</strong></p>
<p>​        相信大家在使用HashMap时最常用的是直接使用HashMap的构造函数创建对象，下面我们先来看一下HashMap提供出来的几个构造函数。</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置负载因子为默认值，其他属性使用默认值</span></span><br><span class="line">	<span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用下方构造函数，眼光直接转向下面一个构造函数，此处直接跳过</span></span><br><span class="line">	<span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在创建对象的时候对初始容量进行设置，并自行设置一个负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 以上代码平铺直叙，一看就懂</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到了这一行代码，可能会稍微有点懵</span></span><br><span class="line">	<span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这个构造函数中，对入参进行必要的校验之后，开始对需要创建的对象属性进行赋值。可以看到参数校验完成之后，分别对<strong>loanFactor</strong>和<strong>threshold</strong>这两个变量进行赋值，对于<strong>threshold</strong>的赋值，可能多少会有一点疑惑，为什么不是直接用<strong>initialCapacity*loadFactor</strong>，而是要单独写一个方法来进行赋值呢？</p>
<p>​        带着上面的疑惑，点开了<code>tableSizeFor(initialCapacity)</code>方法，看到了下面的真容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码很是简洁，但运算逻辑却需要仔细推敲</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上一步调用时传入的initialCapacity - 1</span></span><br><span class="line">    <span class="comment">// 此处假设我们初始化传入的数值为10</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">// n = 9</span></span><br><span class="line">    <span class="comment">/* 这一行包含了这几个步骤：</span></span><br><span class="line"><span class="comment">     * （1）n先无符号右移1位 0***1001 &gt;&gt;&gt; 1 = 0***0100</span></span><br><span class="line"><span class="comment">     * （2）n与n右移一位的值进行或运算 0***1001 | 0***0100 = 0***1101</span></span><br><span class="line"><span class="comment">     * （3）将计算出来的最新的值赋值给n n = 0***1101</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// n = 0***1101</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// n &gt;&gt;&gt; 2 = 0***0011, 0***1101 | 0***0011 = 0***1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>; <span class="comment">// n = 0***1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>; <span class="comment">// n = 0***1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">// n = 0***1111</span></span><br><span class="line">    <span class="comment">// 传值正常的情况下，最终返回的n大小一定为&gt;=initialCapacity的2^&#123;N&#125;或是MAXIMUM_CAPACITY</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        到此为止，<strong>threshold</strong>的赋值过程就完成了，构造函数创建对象的时候对<strong>threshold</strong>赋的初始值为不小于初始容量的</p>
</li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>